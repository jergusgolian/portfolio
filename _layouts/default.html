<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ page.title }} | {{ site.title }}</title>
    <link rel="stylesheet" href="{{ '/style.css' | relative_url }}">
    <link rel="icon" href="{{ '/img/logo.png' | relative_url }}">
</head>
<body>
    <div class="circle"></div>
    <div class="small-circle"></div>
    <nav>
        <a href="{{ site.baseurl }}/#landing" style="display: flex; align-items: center;">
            <img src="{{ '/img/logo.png' | relative_url }}" alt="logo" width="50" class="nd logo">
            <h1>Jerguš Golian</h1>
        </a>
        <button class="hamburger-toggle" aria-expanded="false" aria-controls="main-menu">
            <span class="bar"></span>
            <span class="bar"></span>
            <span class="bar"></span>
        </button>
        <ul>
            <li class><a href="{{ site.baseurl }}/#info">O mne</a></li>
            <li class><a href="{{ site.baseurl }}/#design">Design</a></li>
            <li class><a href="{{ site.baseurl }}/#videomaking">Videotvorba</a></li>
            <li class="last-li"><a href="{{ site.baseurl }}/#coding">Programovanie</a></li>
        </ul>
        <div class="indicator"></div>
    </nav>
    <div class="main">
        {{ content }}
        <div class="foot"></div>
    </div>
    
    <script>
        // Variable definitions MUST be at the top
        const nav = document.querySelector('nav');
        const hamburger = document.querySelector('.hamburger-toggle');
        // Select all links starting with # (navbar and web-buttons)
        const allHashLinks = document.querySelectorAll('a[href^="#"]'); 
        const sections = document.querySelectorAll('.main > div, #landing');
        const indicator = document.querySelector('.indicator');
        // CRITICAL: Ensure homeLink variable is correctly defined
        const homeLink = document.querySelector('nav a:first-child'); 
        
        let isScrollingByClick = false; // Flag to disable scroll-spy after a user click
        window.scrollTimeout = null; // Helper for the timeout
        
        // --- 1. INDICATOR POSITION LOGIC ---
        function updateIndicatorPosition(activeElement) {
            if (!activeElement || window.innerWidth < 1024) { 
                indicator.style.display = 'none';
                return;
            }
            indicator.style.display = 'block';
            
            // Use the active element's rectangle for positioning
            const navRect = nav.getBoundingClientRect();
            const elementRect = activeElement.getBoundingClientRect();
            
            const newLeft = elementRect.left - navRect.left - 50;
            const newTop = 10;
            
            let newHeight = elementRect.height;
            let newWidth = elementRect.width;
            const firstLi = document.querySelector('nav ul li'); 
        
            // This block handles the custom sizing for the logo link (homeLink)
            if (activeElement === homeLink && firstLi) {
                newHeight = firstLi.getBoundingClientRect().height;
                // Use full width of the logo link for the indicator
                newWidth = elementRect.width; 
            } else {
                // This is for the <li> elements
                newWidth = elementRect.width + 100;
            }
            
            indicator.style.left = `${newLeft}px`;
            indicator.style.width = `${newWidth}px`;
            indicator.style.height = `${newHeight}px`; 
            indicator.style.top = `${newTop + 5}px`; 
            indicator.style.transition = 'left 0.3s ease-out, width 0.3s ease-out, top 0.3s ease-out';
        }
        
        // --- 2. UNIVERSAL HASH LINK HANDLER (Fixes Navbar & Buttons) ---
        allHashLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                const hash = link.getAttribute('href');
                // Only handle internal scrolling links
                if (hash.length > 1 && hash.startsWith('#')) {
                    e.preventDefault();
                    
                    isScrollingByClick = true; // Set flag to disable scroll-spy
                    
                    const targetElement = document.querySelector(hash);
                    if (targetElement) {
                        // Smooth scroll to the section
                        targetElement.scrollIntoView({ behavior: 'smooth' });
                    }
                    
                    // Handle active class for NAV links only
                    if (link.closest('nav')) {
                         // Remove all existing active classes
                         document.querySelectorAll('nav .active').forEach(el => el.classList.remove('active'));
                         
                         // Determine activation target (li for menu items, or 'a' for logo)
                         const activationTarget = link.closest('li') || link;
                         activationTarget.classList.add('active');
                         updateIndicatorPosition(activationTarget);
                         
                         // Close mobile menu
                         nav.classList.remove('menu-open');
                         hamburger.setAttribute('aria-expanded', false);
                    }
        
                    // Reset the flag after smooth scroll is complete (1 second)
                    clearTimeout(window.scrollTimeout);
                    window.scrollTimeout = setTimeout(() => { isScrollingByClick = false; }, 1000);
                }
            });
        });
        
        // --- 3. HAMBURGER MENU TOGGLE ---
        hamburger.addEventListener('click', () => {
            nav.classList.toggle('menu-open');
            const isExpanded = nav.classList.contains('menu-open');
            hamburger.setAttribute('aria-expanded', isExpanded);
        });
        
        window.addEventListener('resize', () => {
            const currentActive = document.querySelector('nav .active');
            updateIndicatorPosition(currentActive);
        });
        
        // --- 4. SCROLL-SPY LOGIC ---
        const observerOptions = {
            root: null, 
            rootMargin: '-30% 0px -30% 0px', 
            threshold: 0
        };
        
        function observerCallback(entries) {
            if (isScrollingByClick) return; // Check flag: Do nothing if the user just clicked a link
            
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.id;
                    
                    // Find the corresponding link for the intersecting section
                    const activeLink = document.querySelector(`nav a[href="#${id}"]`);
        
                    if (activeLink) {
                        // Remove existing active classes
                        document.querySelectorAll('nav .active').forEach(el => el.classList.remove('active'));
                        
                        // Determine activation target (li for menu items, or 'a' for logo)
                        const activationTarget = activeLink.closest('li') || activeLink;
                        
                        // Add active class
                        activationTarget.classList.add('active');
                        updateIndicatorPosition(activationTarget);
                    }
                }
            });
        }
        
        const observer = new IntersectionObserver(observerCallback, observerOptions);
        sections.forEach(sec => observer.observe(sec));
        
        // --- 5. CRITICAL INITIALIZATION (Fixes the missing indicator on load) ---
        window.onload = function() {
            window.scrollTo(0, 0);
            // CRITICAL: Ensure the 'active' class is on the element that the indicator code expects
            if (homeLink) {
                homeLink.classList.add('active'); // Add active class to the <a> container
                updateIndicatorPosition(homeLink); // Pass the container to the indicator
            }
        };
        
        // --- 6. CUSTOM CURSOR LOGIC (Retained from previous working version) ---
        console.clear();
        const circleElement = document.querySelector('.circle');
        const scircleElement = document.querySelector('.small-circle');
        
        document.addEventListener('mousedown', () => {
            scircleElement.classList.add('clicked');
        });
        
        document.addEventListener('mouseup', () => {
            scircleElement.classList.remove('clicked');
        });
        
        const interactiveElements = document.querySelectorAll('a, button, .web-button');
        function addHoverClass() {
            scircleElement.classList.add('hovering');
        }
        function removeHoverClass() {
            scircleElement.classList.remove('hovering');
        }
        
        interactiveElements.forEach(element => {
            element.addEventListener('mouseenter', addHoverClass);
            element.addEventListener('mouseleave', removeHoverClass);
        });
        
        const mouse = { x: 0, y: 0 };
        const previousMouse = { x: 0, y: 0 }
        const circle = { x: 0, y: 0 };
        let currentScale = 0;
        let currentAngle = 0;
        
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.x;
            mouse.y = e.y;
        });
        
        const speed = 0.5;
        
        const tick = () => {
            // MOVE
            circle.x += (mouse.x - circle.x) * speed;
            circle.y += (mouse.y - circle.y) * speed;
            const translateTransform = `translate(${circle.x}px, ${circle.y}px)`;
        
            // SQUEEZE
            const deltaMouseX = mouse.x - previousMouse.x;
            const deltaMouseY = mouse.y - previousMouse.y;
            previousMouse.x = mouse.x;
            previousMouse.y = mouse.y;
            const mouseVelocity = Math.min(Math.sqrt(deltaMouseX**2 + deltaMouseY**2) * 4, 150); 
            const scaleValue = (mouseVelocity / 150) * 0.5;
            currentScale += (scaleValue - currentScale) * speed;
            let scaleTransform = `scale(${1 + currentScale}, ${1 - currentScale})`;
        
            // ROTATE
            const angle = Math.atan2(deltaMouseY, deltaMouseX) * 180 / Math.PI;
            if (mouseVelocity > 20) {
                currentAngle = angle;
            }
            const rotateTransform = `rotate(${currentAngle}deg)`;
        
            // Apply all transformations
            circleElement.style.transform = `${translateTransform} ${rotateTransform} ${scaleTransform}`;
            scircleElement.style.transform = `${translateTransform} ${rotateTransform} ${scaleTransform}`;
            
            window.requestAnimationFrame(tick);
        }
        
        // Start the animation loop
        tick();
    </script>
</body>
</html>
