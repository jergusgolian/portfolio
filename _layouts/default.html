<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ page.title }} | {{ site.title }}</title>
    <link rel="stylesheet" href="{{ '/style.css' | relative_url }}">
    <link rel="icon" href="{{ '/img/logo.png' | relative_url }}">
</head>
<body>
    <div class="circle"></div>
    <div class="small-circle"></div>
    <nav>
        <a href="{{ site.baseurl }}/#landing" style="display: flex; align-items: center;">
            <img src="{{ '/img/logo.png' | relative_url }}" alt="logo" width="50" class="nd logo">
            <h1>Jerguš Golian</h1>
        </a>
        <button class="hamburger-toggle" aria-expanded="false" aria-controls="main-menu">
            <span class="bar"></span>
            <span class="bar"></span>
            <span class="bar"></span>
        </button>
        <ul>
            <li class><a href="{{ site.baseurl }}/#info">O mne</a></li>
            <li class><a href="{{ site.baseurl }}/#design">Design</a></li>
            <li class><a href="{{ site.baseurl }}/#videomaking">Videotvorba</a></li>
            <li class="last-li"><a href="{{ site.baseurl }}/#coding">Programovanie</a></li>
        </ul>
        <div class="indicator"></div>
    </nav>
    <div class="main">
        {{ content }}
        <div class="foot"></div>
    </div>
    
    <script>
        const nav = document.querySelector('nav');
        const hamburger = document.querySelector('.hamburger-toggle');
        const allHashLinks = document.querySelectorAll('a[href^="#"]'); // Selects all internal hash links (nav and buttons)
        const sections = document.querySelectorAll('.main > div, #landing');
        const indicator = document.querySelector('.indicator');
        const homeLink = document.querySelector('nav a:first-child');
        
        let isScrollingByClick = false; // Flag to disable scroll-spy after a user click
        window.scrollTimeout = null; // Helper for the timeout
        
        // --- 1. INDICATOR POSITION LOGIC ---
        function updateIndicatorPosition(activeElement) {
            if (!activeElement || window.innerWidth < 1024) { 
                indicator.style.display = 'none';
                return;
            }
            indicator.style.display = 'block';
            const navRect = nav.getBoundingClientRect();
            const elementRect = activeElement.getBoundingClientRect();
            const newLeft = elementRect.left - navRect.left - 50;
            const newTop = 10;
            let newHeight;
            let newWidth = elementRect.width;
            const firstLi = document.querySelector('nav ul li'); 
        
            if (activeElement === homeLink && firstLi) {
                newHeight = firstLi.getBoundingClientRect().height;
                newWidth = elementRect.width * 0.5;
            } else {
                newHeight = elementRect.height;
                newWidth = elementRect.width + 100;
            }
            indicator.style.left = `${newLeft}px`;
            indicator.style.width = `${newWidth}px`;
            indicator.style.height = `${newHeight}px`; 
            indicator.style.top = `${newTop + 5}px`; 
            indicator.style.transition = 'left 0.3s ease-out, width 0.3s ease-out, top 0.3s ease-out';
        }
        
        // --- 2. UNIVERSAL HASH LINK HANDLER (Fixes Navbar & Buttons) ---
        allHashLinks.forEach(link => {
            link.addEventListener('click', (e) => {
                const hash = link.getAttribute('href');
                // Only handle internal scrolling links
                if (hash.length > 1 && hash.startsWith('#')) {
                    e.preventDefault();
                    
                    isScrollingByClick = true; // Set flag to disable scroll-spy
                    
                    // Scroll to the target element manually
                    const targetElement = document.querySelector(hash);
                    if (targetElement) {
                        targetElement.scrollIntoView({ behavior: 'smooth' });
                    }
                    
                    // Handle active class for NAV links only
                    if (link.closest('nav')) {
                         document.querySelectorAll('nav .active').forEach(el => el.classList.remove('active'));
                         // Determine activation target (li for menu items, or 'a' for logo)
                         const activationTarget = link.closest('li') || link;
                         activationTarget.classList.add('active');
                         updateIndicatorPosition(activationTarget);
                         
                         // Close mobile menu
                         nav.classList.remove('menu-open');
                         hamburger.setAttribute('aria-expanded', false);
                    }
        
                    // Reset the flag after smooth scroll is complete (1 second is usually safe)
                    clearTimeout(window.scrollTimeout);
                    window.scrollTimeout = setTimeout(() => { isScrollingByClick = false; }, 1000);
                }
            });
        });
        
        // --- 3. HAMBURGER MENU TOGGLE ---
        hamburger.addEventListener('click', () => {
            nav.classList.toggle('menu-open');
            const isExpanded = nav.classList.contains('menu-open');
            hamburger.setAttribute('aria-expanded', isExpanded);
        });
        
        window.addEventListener('resize', () => {
            const currentActive = document.querySelector('nav .active');
            updateIndicatorPosition(currentActive);
        });
        
        // --- 4. SCROLL-SPY LOGIC ---
        const observerOptions = {
            root: null, 
            rootMargin: '-30% 0px -30% 0px', // Adjusted margin for better section detection
            threshold: 0
        };
        
        function observerCallback(entries) {
            if (isScrollingByClick) return; // Check flag: Do nothing if the user just clicked a link
            
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const id = entry.target.id;
                    
                    // Find the corresponding link for the intersecting section
                    const activeLink = document.querySelector(`nav a[href="#${id}"]`);
        
                    if (activeLink) {
                        // Remove existing active classes
                        document.querySelectorAll('nav .active').forEach(el => el.classList.remove('active'));
                        
                        // Determine activation target (li for menu items, or 'a' for logo)
                        const activationTarget = activeLink.closest('li') || activeLink;
                        
                        // Add active class
                        activationTarget.classList.add('active');
                        updateIndicatorPosition(activationTarget);
                    }
                }
            });
        }
        
        const observer = new IntersectionObserver(observerCallback, observerOptions);
        sections.forEach(sec => observer.observe(sec));
        
        // --- 5. INITIALIZATION ---
        window.onload = function() {
            window.scrollTo(0, 0);
            const homeLink = document.querySelector('nav a[href="#landing"]');
            if (homeLink) {
                homeLink.classList.add('active');
                updateIndicatorPosition(homeLink);
            }
        };
        
        // --- 6. CUSTOM CURSOR LOGIC ---
        console.clear();
        
        const circleElement = document.querySelector('.circle');
        const scircleElement = document.querySelector('.small-circle');
        
        // Add mousedown/mouseup listeners for 'clicked' state
        document.addEventListener('mousedown', () => {
            scircleElement.classList.add('clicked');
        });
        
        document.addEventListener('mouseup', () => {
            scircleElement.classList.remove('clicked');
        });
        
        // Select all interactive elements
        const interactiveElements = document.querySelectorAll('a, button, .web-button');
        
        // Function to handle cursor class change on hover
        function addHoverClass() {
            scircleElement.classList.add('hovering');
        }
        
        function removeHoverClass() {
            scircleElement.classList.remove('hovering');
        }
        
        // Add event listeners to all interactive elements
        interactiveElements.forEach(element => {
            element.addEventListener('mouseenter', addHoverClass);
            element.addEventListener('mouseleave', removeHoverClass);
        });
        
        // Create objects to track mouse position and custom cursor position
        const mouse = { x: 0, y: 0 }; // Track current mouse position
        const previousMouse = { x: 0, y: 0 } // Store the previous mouse position
        const circle = { x: 0, y: 0 }; // Track the circle position
        
        // Initialize variables to track scaling and rotation
        let currentScale = 0; // Track current scale value
        let currentAngle = 0; // Track current angle value
        
        // Update mouse position on the 'mousemove' event
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.x;
            mouse.y = e.y;
        });
        
        // Smoothing factor for cursor movement speed (0 = smoother, 1 = instant)
        const speed = 0.5;
        
        // Start animation
        const tick = () => {
            // MOVE
            // Calculate circle movement based on mouse position and smoothing
            circle.x += (mouse.x - circle.x) * speed;
            circle.y += (mouse.y - circle.y) * speed;
            // Create a transformation string for cursor translation
            const translateTransform = `translate(${circle.x}px, ${circle.y}px)`;
        
            // SQUEEZE
            // 1. Calculate the change in mouse position (deltaMouse)
            const deltaMouseX = mouse.x - previousMouse.x;
            const deltaMouseY = mouse.y - previousMouse.y;
            // Update previous mouse position for the next frame
            previousMouse.x = mouse.x;
            previousMouse.y = mouse.y;
            // 2. Calculate mouse velocity using Pythagorean theorem and adjust speed
            const mouseVelocity = Math.min(Math.sqrt(deltaMouseX**2 + deltaMouseY**2) * 4, 150); 
            // 3. Convert mouse velocity to a value in the range [0, 0.5]
            const scaleValue = (mouseVelocity / 150) * 0.5;
            // 4. Smoothly update the current scale
            currentScale += (scaleValue - currentScale) * speed;
            // 5. Create a transformation string for scaling
            let scaleTransform = `scale(${1 + currentScale}, ${1 - currentScale})`;
        
            // ROTATE
            // 1. Calculate the angle using the atan2 function
            const angle = Math.atan2(deltaMouseY, deltaMouseX) * 180 / Math.PI;
            // 2. Check for a threshold to reduce shakiness at low mouse velocity
            if (mouseVelocity > 20) {
                currentAngle = angle;
            }
            // 3. Create a transformation string for rotation
            const rotateTransform = `rotate(${currentAngle}deg)`;
        
            // Apply all transformations to the circle element in a specific order: translate -> rotate -> scale
            circleElement.style.transform = `${translateTransform} ${rotateTransform} ${scaleTransform}`;
            scircleElement.style.transform = `${translateTransform} ${rotateTransform} ${scaleTransform}`;
            
            // Request the next frame to continue the animation
            window.requestAnimationFrame(tick);
        }
        
        // Start the animation loop
        tick();
    </script>
</body>
</html>
